diff -Nru a/Makefile b/Makefile
--- a/Makefile	2013-04-17 20:52:49.000000000 +0800
+++ b/Makefile	2013-07-02 13:17:30.054000359 +0800
@@ -26,7 +26,7 @@
 DESTDIR       = 
 CFLAGS        = -Wall -W -O2
 LDFLAGS       = 
-COPTS         = 
+COPTS         = -DHAVE_LIBPCRE
 RPM_OPT_FLAGS = 
 LIBS          = 
 
@@ -60,6 +60,8 @@
 lua_cflags =  `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_LUASCRIPT $(PKG_CONFIG) --cflags lua5.1` 
 lua_libs =    `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_LUASCRIPT $(PKG_CONFIG) --libs lua5.1` 
 sunos_libs =  `if uname | grep SunOS >/dev/null 2>&1; then echo -lsocket -lnsl -lposix4; fi`
+pcre_cflags = `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_LIBPCRE $(PKG_CONFIG) --cflags libpcre`
+pcre_libs =   `echo $(COPTS) | $(top)/bld/pkg-wrapper HAVE_LIBPCRE $(PKG_CONFIG) --libs libpcre`
 version =     -DVERSION='\"`$(top)/bld/get-version $(top)`\"'
 
 objs = cache.o rfc1035.o util.o option.o forward.o network.o \
@@ -73,8 +75,8 @@
 all : $(BUILDDIR)
 	@cd $(BUILDDIR) && $(MAKE) \
  top="$(top)" \
- build_cflags="$(version) $(dbus_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags)" \
- build_libs="$(dbus_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs)" \
+ build_cflags="$(version) $(dbus_cflags) $(idn_cflags) $(ct_cflags) $(lua_cflags) $(pcre_cflags)" \
+ build_libs="$(dbus_libs) $(idn_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(pcre_libs)" \
  -f $(top)/Makefile dnsmasq 
 
 clean :
@@ -93,8 +95,8 @@
 	@cd $(BUILDDIR) && $(MAKE) \
  top="$(top)" \
  i18n=-DLOCALEDIR=\'\"$(LOCALEDIR)\"\' \
- build_cflags="$(version) $(dbus_cflags) $(ct_cflags) $(lua_cflags) `$(PKG_CONFIG) --cflags libidn`" \
- build_libs="$(dbus_libs) $(ct_libs) $(lua_libs) $(sunos_libs) `$(PKG_CONFIG) --libs libidn`"  \
+ build_cflags="$(version) $(dbus_cflags) $(ct_cflags) $(lua_cflags) $(pcre_cflags) `$(PKG_CONFIG) --cflags libidn`" \
+ build_libs="$(dbus_libs) $(ct_libs) $(lua_libs) $(sunos_libs) $(pcre_libs) `$(PKG_CONFIG) --libs libidn`"  \
  -f $(top)/Makefile dnsmasq
 	for f in `cd $(PO); echo *.po`; do \
 		cd $(top) && cd $(BUILDDIR) && $(MAKE) top="$(top)" -f $(top)/Makefile $${f%.po}.mo; \
diff -Nru a/src/dnsmasq.h b/src/dnsmasq.h
--- a/src/dnsmasq.h	2013-04-17 20:52:49.000000000 +0800
+++ b/src/dnsmasq.h	2013-07-01 16:15:52.489991937 +0800
@@ -116,6 +116,7 @@
 #ifndef HAVE_LINUX_NETWORK
 #  include <net/if_dl.h>
 #endif
+#include <pcre.h>
 
 #if defined(HAVE_LINUX_NETWORK)
 #include <linux/capability.h>
@@ -407,6 +408,8 @@
 #define SERV_COUNTED         512  /* workspace for log code */
 #define SERV_USE_RESOLV     1024  /* forward this domain in the normal way */
 #define SERV_NO_REBIND      2048  /* inhibit dns-rebind protection */
+#define SERV_IS_REGEX       4096  /* server entry is a regex */
+
 
 struct serverfd {
   int fd;
@@ -425,6 +428,8 @@
   char interface[IF_NAMESIZE+1];
   struct serverfd *sfd; 
   char *domain; /* set if this server only handles a domain. */ 
+  pcre *regex;
+  pcre_extra *pextra;
   int flags, tcpfd;
   unsigned int queries, failed_queries;
   struct server *next; 
diff -Nru a/src/forward.c b/src/forward.c
--- a/src/forward.c	2013-04-17 20:52:49.000000000 +0800
+++ b/src/forward.c	2013-07-02 11:34:23.765004927 +0800
@@ -150,11 +150,30 @@
       }
     else if (serv->flags & SERV_HAS_DOMAIN)
       {
+	unsigned int domainlen = matchlen;
+        int serverhit = 0;
+	if (!(serv->flags & SERV_IS_REGEX)) {
 	unsigned int domainlen = strlen(serv->domain);
 	char *matchstart = qdomain + namelen - domainlen;
 	if (namelen >= domainlen &&
 	    hostname_isequal(matchstart, serv->domain) &&
 	    (domainlen == 0 || namelen == domainlen || *(matchstart-1) == '.' ))
+		serverhit = 1;
+	} else { /*Regex Flag Set*/
+	    int captcount = 0;
+	    if (pcre_fullinfo(serv->regex, serv->pextra, PCRE_INFO_CAPTURECOUNT, &captcount) == 0)
+	      {
+		/* C99 dyn-array, or alloca must be used */
+		int ovect[(captcount + 1) * 3];
+		if (pcre_exec(serv->regex, serv->pextra, qdomain, namelen, 0, 0, ovect, (captcount + 1) * 3) > 0)
+		  {
+		    domainlen = (unsigned int) (ovect[1] - ovect[0]);
+		    if (domainlen >= matchlen)
+		      serverhit = 1;
+		  }
+	      }
+	}
+	if (serverhit == 1)
 	  {
 	    if (serv->flags & SERV_NO_REBIND)	
 	      *norebind = 1;
diff -Nru a/src/network.c b/src/network.c
--- a/src/network.c	2013-04-17 20:52:49.000000000 +0800
+++ b/src/network.c	2013-07-02 11:35:17.002001575 +0800
@@ -1000,7 +1000,7 @@
 	      char *s1, *s2;
 	      if (!(new->flags & SERV_HAS_DOMAIN))
 		s1 = _("unqualified"), s2 = _("names");
-	      else if (strlen(new->domain) == 0)
+	      else if (new->domain && strlen(new->domain) == 0)
 		s1 = _("default"), s2 = "";
 	      else
 		s1 = _("domain"), s2 = new->domain;
diff -Nru a/src/option.c b/src/option.c
--- a/src/option.c	2013-04-17 20:52:49.000000000 +0800
+++ b/src/option.c	2013-07-02 13:16:52.753999517 +0800
@@ -1967,12 +1967,18 @@
 	      arg++;
 	    while (rebind || (end = split_chr(arg, '/')))
 	      {
-		char *domain = NULL;
+		char *domain = NULL, *regex = NULL;
+		char *real_end = arg + strlen(arg);
 		/* elide leading dots - they are implied in the search algorithm */
 		while (*arg == '.') arg++;
 		/* # matches everything and becomes a zero length domain string */
 		if (strcmp(arg, "#") == 0)
 		  domain = "";
+		else if (*arg == ':' && *(real_end - 1) == ':')
+		  {
+		    *(real_end - 1) = '\0';
+		    regex = arg + 1;
+		  }
 		else if (strlen (arg) != 0 && !(domain = canonicalise_opt(arg)))
 		  option = '?';
 		serv = opt_malloc(sizeof(struct server));
@@ -1980,7 +1986,22 @@
 		serv->next = newlist;
 		newlist = serv;
 		serv->domain = domain;
-		serv->flags = domain ? SERV_HAS_DOMAIN : SERV_FOR_NODOTS;
+		serv->flags = domain || regex ? SERV_HAS_DOMAIN : SERV_FOR_NODOTS;
+		if (regex)
+		  {
+		    const char *error;
+		    int erroff;
+		    serv->regex = pcre_compile(regex, 0, &error, &erroff, NULL);
+
+		    if (!serv->regex)
+		      {
+			 option = '?';
+			 problem = _(error);
+			 break;
+		      }
+		    serv->flags |= SERV_IS_REGEX;
+		    serv->pextra = pcre_study(serv->regex, 0, &error);
+		  }
 		arg = end;
 		if (rebind)
 		  break;
